/*
 * Remy Lewis(remyknight1119@gmail.com)
 */

#include "quic_test.h"

#include <stdio.h>
#include <string.h>

#include <tbquic/quic.h>
#include <tbquic/tls.h>

#include "tls_cipher.h"
#include "quic_local.h"
#include "tls.h"
#include "tls_lib.h"
#include "list.h"
#include "common.h"

static const uint16_t tls_sigalgs[] = {
    TLSEXT_SIGALG_ECDSA_SECP256R1_SHA256,
    TLSEXT_SIGALG_RSA_PSS_RSAE_SHA256,
    TLSEXT_SIGALG_RSA_PKCS1_SHA256,
    TLSEXT_SIGALG_ECDSA_SECP384R1_SHA384,
    TLSEXT_SIGALG_RSA_PSS_RSAE_SHA384,
    TLSEXT_SIGALG_RSA_PKCS1_SHA384,
    TLSEXT_SIGALG_RSA_PSS_RSAE_SHA512,
    TLSEXT_SIGALG_RSA_PKCS1_SHA512,
    TLSEXT_SIGALG_RSA_PKCS1_SHA1,
};

static const char clienthello_serverhello[] =
    "010000CA030393B44BC2E8752CB9F1AD82B9406D8BD0ECD67393B28B1473AB2D932AAD2E832520E6F3E439CCE97CF59AC99BF43F535F27F3B90AB5390F0D386B63AB1BFD5990EB000813021301130300FF01000079000B000403000102000A000C000A001D0017001E001900180016000000170000000D001E001C040305030603080708080809080A080B080408050806040105010601002B0003020304002D00020101003300260024001D0020A7BAEAF2A19618CAD58FAFE3F6FD4FE89975CF4CC7CDB9FFBC6D263DF36DFA46020000760303689779BB33A28B85FF61ECB01E4FCDED8492C229A2002B372444FFDD9CE5371D20E6F3E439CCE97CF59AC99BF43F535F27F3B90AB5390F0D386B63AB1BFD5990EB130200002E002B0002030400330024001D00204779DD2A2B40B3101D9ED1C42F6886B4534E21DB8D1C513A6A4AFA79B075333A";
static const char update_msg[] =
    "0800000200000B0004E8000004E40004DF308204DB308203C3A0030201020203044E05300D06092A864886F70D01010B05003081AB310B3009060355040613025553311330110603550408130A43616C69666F726E6961311230100603550407130953756E6E7976616C653111300F060355040A1308466F7274696E6574311E301C060355040B1315436572746966696361746520417574686F72697479311B301906035504031312666F7274696E65742D7375626361323030313123302106092A864886F70D0109011614737570706F727440666F7274696E65742E636F6D3020170D3139303232373233353030395A180F32303536303131393033313430375A308196310B3009060355040613025553311330110603550408130A43616C69666F726E6961311230100603550407130953756E6E7976616C653111300F060355040A1308466F7274696E65743111300F060355040B1308466F727469414443311330110603550403130A466F727469414443564D3123302106092A864886F70D0109011614737570706F727440666F7274696E65742E636F6D30820122300D06092A864886F70D01010105000382010F003082010A0282010100CBD25313835D84E4A386ECEC070BA5264222C74F511A6BEDBDE9426E410674B85CAA587490F6E0A3B622157963142973C6E89CD5BC4A0554D7C7D5C8FC95E74B67297278CA2334BD5A2F5E60B7A9AC6CB7CA037BA901BFE5B61821D9F14D19F9617A6E4F456D92EE8C5AAF8D7AFD769EC15343B4DB0AD455C54A5F5733DB925C24B0A20698A123864B8C5821C92F26143E9A1508D5B4A8D90D0E600E4259671D223D7588D4BB4F4D7F7B31B042EA5C7A3FE88416F66A94E4385108DDF4546516321C10DEF5ED4D1CA82667059F559B9027265A9B216694F6FD10AA7FEA37BAD30C508CFD4BCC74B868A027B4FE514FD4BA35C3084AA20BA9E28FD395A69BD5810203010001A382011730820113301D0603551D0E041604142EC1622503BC3883A19314A231141FA5A67284F93081D30603551D230481CB3081C88014982B253C30CA2C2B56E7DBFC5933B3DC3D5B6AD7A181ABA481A83081A5310B3009060355040613025553311330110603550408130A43616C69666F726E6961311230100603550407130953756E6E7976616C653111300F060355040A1308466F7274696E6574311E301C060355040B1315436572746966696361746520417574686F72697479311530130603550403130C666F7274696E65742D6361323123302106092A864886F70D0109011614737570706F727440666F7274696E65742E636F6D82022001300C0603551D130101FF04023000300E0603551D0F0101FF040403020780300D06092A864886F70D01010B050003820101007F8D9F95C9B9019F3D248F920BC23ACD4259FE5C9098546333B9652A6236EEB9053EB9653838ECFF250B82AC7FB35A3F422A7A5F377F90BD253BAC1729EBB1E03BF37ABEFC207F05C26D91594E4B61548B22F6D3D7447C508D8D805C6D0AC71D0EB2985D6C8F686D719DA34150BF26E268EB88F7AE9E26A42ACDD5EEC6DEECF89B0789320D8C7833AB421ABB0C5244E2EC14C98ADF1F3D6A5C9D0727B435EE76E268D889CF0001E06573AFCC8EC9B4AFC823AA97015E9E384084AA30C7409CEAFC4479D55755FF0E3CF363D74643C3AD755FBE29BFEC1724F9ACFAD221FB7EF51456D07B2892C3B5C4D956FF5E8E062EDCAF06C45660843A15AB76EB5EB30AD300000F0001040804010082A60D13C763A83BE0D76C3BD7BA943E6E5510A2EAC9549BADDE9163A8EDF3CE6FC337F0C22A0F2CBE8D885BE55217DFE3791F7657E0046A3CC837371F23759BF277C8337F0A8CA5C588E5354E1D329B8B3F66C9350926CEF2C9B716028EFA79412C39D599DFEF911178FA0B63AF44EB97EA1A389A1E7194D53E7F12ABA94201D9FEDA1BDDB243AAED4F44CC5F3E32F3B1ABC44C4C43AEAFBB061634EDD8CE278DC56A21402BF1FB24CCE05EE3D3A6FD3B04D842A51D375B99D07A6379FD210D43C5083C9482FA0FA03328856F53A80C569E22DDCD97E164C061C6A6CF17843207D5BCADB9834ADB2A0DD3F80BC9B24B84FB6D00B8637EAD758485483E3D2876";

int TlsCipherListTest(void)
{
    TlsCipherListNode *pos = NULL;
    HLIST_HEAD(h);
    char ciphers[sizeof(TLS_CIPHERS_DEF)] = {};
    int offset = 0;

    if (TlsCreateCipherList(&h, TLS_CIPHERS_DEF,
                    sizeof(TLS_CIPHERS_DEF) - 1) < 0) {
        return -1;
    }

    hlist_for_each_entry(pos, &h, node)	{
        if (offset != 0) {
            offset += snprintf(&ciphers[offset], sizeof(ciphers) - offset,
                        TLS_CIPHERS_SEP);
        }
        offset += snprintf(&ciphers[offset], sizeof(ciphers) - offset,
                    "%s", pos->cipher->name);
        if (offset >= sizeof(ciphers)) {
            TlsDestroyCipherList(&h);
            return -1;
        }
    }

    if (strcmp(ciphers, TLS_CIPHERS_DEF) != 0) {
        TlsDestroyCipherList(&h);
        return -1;
    }

    TlsDestroyCipherList(&h);
    return 1;
}

static const char *TlsFindServerHello(const char *start, size_t total_len)
{
    char *sub_str = "020000";
    const char *server_hello = NULL;
    const char *curr = start;
    const char *len = NULL;
    uint8_t length = 0;
    int offset = 0;

    while (1) {
        server_hello = strstr(curr, sub_str);
        if (server_hello == NULL) {
            break;
        }

        len = server_hello + strlen(sub_str);
        str2hex(&length, (void *)len, sizeof(length));
        if (length == (total_len - (len - start) - 2)/2) {
            offset = (server_hello - start)/2;
            str2hex(&length, (void *)(start + strlen(sub_str)), sizeof(length));
            if (offset == (length + 4)) {
                break;
            }
        }
        curr = len;
    }

    return server_hello;
}

static int TlsCtxClientExtensionSet(QUIC_CTX *ctx)
{
    uint16_t groups[] = {
        TLS_SUPPORTED_GROUPS_X25519,
        TLS_SUPPORTED_GROUPS_SECP256R1,
        TLS_SUPPORTED_GROUPS_SECP384R1,
    };
    int ret = -1;

    if (QuicCtxCtrl(ctx, QUIC_CTRL_SET_GROUPS, groups,
                QUIC_NELEM(groups)) < 0) {
        goto out;
    }

    if (QuicCtxCtrl(ctx, QUIC_CTRL_SET_SIGALGS, (void *)tls_sigalgs,
                QUIC_NELEM(tls_sigalgs)) < 0) {
        goto out;
    }

    ret = 0;
out:
    return ret;
}
 
int TlsClientHandshakeReadTest(void)
{
    QUIC_CTX *ctx = NULL;
    QUIC *quic = NULL;
    TLS *tls = NULL;
    QUIC_BUFFER *buf = NULL;
    BIO *rbio = NULL;
    BIO *wbio = NULL;
    const char *server_hello = NULL;
    size_t msg_len = 0;
    int offset = 0;
    int err = 0;
    int ret = -1;

    ctx = QuicCtxNew(QuicClientMethod());
    if (ctx == NULL) {
        goto out;
    }

    if (TlsCtxClientExtensionSet(ctx) < 0) {
        goto out;
    }

    quic = QuicNew(ctx);
    if (quic == NULL) {
        goto out;
    }

    QUIC_set_connect_state(quic);
    rbio = BIO_new(BIO_s_mem());
    if (rbio == NULL) {
        goto out;
    }

    wbio = BIO_new(BIO_s_mem());
    if (wbio == NULL) {
        goto out;
    }
    QUIC_set_bio(quic, rbio, wbio);

    rbio = NULL;
    wbio = NULL;

    ret = QuicDoHandshake(quic);
    if (ret < 0) {
        err = QUIC_get_error(quic, ret);
        if (err != QUIC_ERROR_WANT_READ) {
            printf("Do Client Handshake failed\n");
            goto out;
        }
    }

    server_hello = TlsFindServerHello(clienthello_serverhello,
            sizeof(clienthello_serverhello) - 1);
    if (server_hello == NULL) {
        goto out;
    }

    offset = (server_hello - clienthello_serverhello)/2;
    printf("offset = %d\n", offset);
    buf = QUIC_TLS_BUFFER(quic);
    str2hex((void *)QuicBufHead(buf), (void *)clienthello_serverhello,
            offset);
    QuicBufSetDataLength(buf, offset);
    QuicBufReserve(buf);
    msg_len = strlen(server_hello)/2;
    str2hex((void *)QuicBufData(buf), (void *)server_hello, msg_len);
    QuicBufSetDataLength(buf, msg_len);
    msg_len = strlen(update_msg)/2;
    str2hex((void *)(QuicBufData(buf) + QuicBufGetDataLength(buf)),
            (void *)update_msg, msg_len);
    QuicBufAddDataLength(buf, msg_len);

    tls = &quic->tls;
    tls->kexch_key = TlsGeneratePkeyGroup(tls, EC_NAMED_CURVE_X25519);
    if (tls->kexch_key == NULL) {
        printf("TLS Gen Pkey Group failed!\n");
        goto out;
    }

    if (TlsDoHandshake(tls) == QUIC_FLOW_RET_ERROR) {
        printf("TLS Hadshake failed!\n");
        goto out;
    }

    ret = 1;
out:
    BIO_free(wbio);
    BIO_free(rbio);
    QuicFree(quic);
    QuicCtxFree(ctx);
    return ret;
}

