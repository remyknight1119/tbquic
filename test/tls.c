/*
 * Remy Lewis(remyknight1119@gmail.com)
 */

#include "quic_test.h"

#include <stdio.h>
#include <string.h>

#include <tbquic/quic.h>
#include <tbquic/tls.h>

#include "tls_cipher.h"
#include "quic_local.h"
#include "tls.h"
#include "tls_lib.h"
#include "list.h"
#include "tls_test.h"
#include "common.h"

static const uint16_t tls_sigalgs[] = {
    TLSEXT_SIGALG_ECDSA_SECP256R1_SHA256,
    TLSEXT_SIGALG_RSA_PSS_RSAE_SHA256,
    TLSEXT_SIGALG_RSA_PKCS1_SHA256,
    TLSEXT_SIGALG_ECDSA_SECP384R1_SHA384,
    TLSEXT_SIGALG_RSA_PSS_RSAE_SHA384,
    TLSEXT_SIGALG_RSA_PKCS1_SHA384,
    TLSEXT_SIGALG_RSA_PSS_RSAE_SHA512,
    TLSEXT_SIGALG_RSA_PKCS1_SHA512,
    TLSEXT_SIGALG_RSA_PKCS1_SHA1,
};

static const char clienthello_serverhello[] =
    "010000CA030382977AE6DC0E5B118CD5AD804F9B524C96D717025D022A032EDFB1450AA9576B204594235051E54F79A7641247BF16EB74B80EEF7E64121C6FCFD0F3D2D505BC76000813021301130300FF01000079000B000403000102000A000C000A001D0017001E001900180016000000170000000D001E001C040305030603080708080809080A080B080408050806040105010601002B0003020304002D00020101003300260024001D0020C485C1CB54149D53B19B4535EC4B6C6E4AA3E3AA90279A0330A4319B2CB265510200007603037DB0C4C8107CE023E366C69D30ADACCDFACB3927B825ED04AEEA47623209114D204594235051E54F79A7641247BF16EB74B80EEF7E64121C6FCFD0F3D2D505BC76130200002E002B0002030400330024001D00206C61ED6BF8BFF74F80D12CF1CD483E35D68FDD226AF68A2307324EC8E6A0D62F";
static const char update_msg[] =
    "0800000200000B0004E8000004E40004DF308204DB308203C3A0030201020203044E05300D06092A864886F70D01010B05003081AB310B3009060355040613025553311330110603550408130A43616C69666F726E6961311230100603550407130953756E6E7976616C653111300F060355040A1308466F7274696E6574311E301C060355040B1315436572746966696361746520417574686F72697479311B301906035504031312666F7274696E65742D7375626361323030313123302106092A864886F70D0109011614737570706F727440666F7274696E65742E636F6D3020170D3139303232373233353030395A180F32303536303131393033313430375A308196310B3009060355040613025553311330110603550408130A43616C69666F726E6961311230100603550407130953756E6E7976616C653111300F060355040A1308466F7274696E65743111300F060355040B1308466F727469414443311330110603550403130A466F727469414443564D3123302106092A864886F70D0109011614737570706F727440666F7274696E65742E636F6D30820122300D06092A864886F70D01010105000382010F003082010A0282010100CBD25313835D84E4A386ECEC070BA5264222C74F511A6BEDBDE9426E410674B85CAA587490F6E0A3B622157963142973C6E89CD5BC4A0554D7C7D5C8FC95E74B67297278CA2334BD5A2F5E60B7A9AC6CB7CA037BA901BFE5B61821D9F14D19F9617A6E4F456D92EE8C5AAF8D7AFD769EC15343B4DB0AD455C54A5F5733DB925C24B0A20698A123864B8C5821C92F26143E9A1508D5B4A8D90D0E600E4259671D223D7588D4BB4F4D7F7B31B042EA5C7A3FE88416F66A94E4385108DDF4546516321C10DEF5ED4D1CA82667059F559B9027265A9B216694F6FD10AA7FEA37BAD30C508CFD4BCC74B868A027B4FE514FD4BA35C3084AA20BA9E28FD395A69BD5810203010001A382011730820113301D0603551D0E041604142EC1622503BC3883A19314A231141FA5A67284F93081D30603551D230481CB3081C88014982B253C30CA2C2B56E7DBFC5933B3DC3D5B6AD7A181ABA481A83081A5310B3009060355040613025553311330110603550408130A43616C69666F726E6961311230100603550407130953756E6E7976616C653111300F060355040A1308466F7274696E6574311E301C060355040B1315436572746966696361746520417574686F72697479311530130603550403130C666F7274696E65742D6361323123302106092A864886F70D0109011614737570706F727440666F7274696E65742E636F6D82022001300C0603551D130101FF04023000300E0603551D0F0101FF040403020780300D06092A864886F70D01010B050003820101007F8D9F95C9B9019F3D248F920BC23ACD4259FE5C9098546333B9652A6236EEB9053EB9653838ECFF250B82AC7FB35A3F422A7A5F377F90BD253BAC1729EBB1E03BF37ABEFC207F05C26D91594E4B61548B22F6D3D7447C508D8D805C6D0AC71D0EB2985D6C8F686D719DA34150BF26E268EB88F7AE9E26A42ACDD5EEC6DEECF89B0789320D8C7833AB421ABB0C5244E2EC14C98ADF1F3D6A5C9D0727B435EE76E268D889CF0001E06573AFCC8EC9B4AFC823AA97015E9E384084AA30C7409CEAFC4479D55755FF0E3CF363D74643C3AD755FBE29BFEC1724F9ACFAD221FB7EF51456D07B2892C3B5C4D956FF5E8E062EDCAF06C45660843A15AB76EB5EB30AD300000F00010408040100C434CC8073D0ADC2188F05421A8CE5F42F943C7A56A77D8B7E8BB4E76AFB567DB4B09A5A8683A8C54F24E991419EBF71290D368098F523875CBFFF9C1A73C8309A842694ADEFC8ACB395387D206A02D74F2A86F57DE698D38CC023ADA1F9AD17B53907A9D121852426C11B6EFB610ECEB68F493D140E1DB86DB60D9B8610B1D3687CAD514F8E6D005FDFBB0C1227C59EC4971C04607FBE37B4A467B712516F86CF3B4E96297284C5A533976D05889794CC6F7D40F5A6AB3A090EF7C2B6C6F84FC066932D994887D49A8D3E33FA8FDA94041DB7353DB2E71AD677AA2E53297F91FA73F92A562ABD1A09ECC199B41EB286650C92C0037EB3F4E0C5A0E9E60EA24C";

static char handshake_insecret[] =
    "B4F4BF827AB798930E366CB362DC862C792290D555E1574B3018B6DA841F44603C467CF5361479B726FB20873A08D36E00000000000000000000000000000000";
static char handshake_secret[] =
    "D47FDBF6476C3027C073DD98750519503260AEE131166DD1DBEC0EE8C8DEDA1EACFE7F9B4978AD0771F0D4C7E6EEDE48";

static int handshake_secret_cmp_ok;

static void QuicHandshakeSecretComp(uint8_t *secret)
{
    uint8_t hsecret[EVP_MAX_MD_SIZE] = {};
    size_t len = 0;

    len = (sizeof(handshake_secret) - 1)/2;
    return;
    str2hex(hsecret, handshake_secret, len);
    if (memcmp(secret, hsecret, len) == 0) {
        handshake_secret_cmp_ok = 1;
    } else {
        handshake_secret_cmp_ok = 0;
        QuicPrint(secret, len);
    }
}

int TlsCipherListTest(void)
{
    TlsCipherListNode *pos = NULL;
    HLIST_HEAD(h);
    char ciphers[sizeof(TLS_CIPHERS_DEF)] = {};
    int offset = 0;

    if (TlsCreateCipherList(&h, TLS_CIPHERS_DEF,
                    sizeof(TLS_CIPHERS_DEF) - 1) < 0) {
        return -1;
    }

    hlist_for_each_entry(pos, &h, node)	{
        if (offset != 0) {
            offset += snprintf(&ciphers[offset], sizeof(ciphers) - offset,
                        TLS_CIPHERS_SEP);
        }
        offset += snprintf(&ciphers[offset], sizeof(ciphers) - offset,
                    "%s", pos->cipher->name);
        if (offset >= sizeof(ciphers)) {
            TlsDestroyCipherList(&h);
            return -1;
        }
    }

    if (strcmp(ciphers, TLS_CIPHERS_DEF) != 0) {
        TlsDestroyCipherList(&h);
        return -1;
    }

    TlsDestroyCipherList(&h);
    return 1;
}

static int TlsCtxClientExtensionSet(QUIC_CTX *ctx)
{
    uint16_t groups[] = {
        TLS_SUPPORTED_GROUPS_X25519,
        TLS_SUPPORTED_GROUPS_SECP256R1,
        TLS_SUPPORTED_GROUPS_SECP384R1,
    };
    int ret = -1;

    if (QuicCtxCtrl(ctx, QUIC_CTRL_SET_GROUPS, groups,
                QUIC_NELEM(groups)) < 0) {
        goto out;
    }

    if (QuicCtxCtrl(ctx, QUIC_CTRL_SET_SIGALGS, (void *)tls_sigalgs,
                QUIC_NELEM(tls_sigalgs)) < 0) {
        goto out;
    }

    ret = 0;
out:
    return ret;
}
 
int TlsClientHandshakeReadTest(void)
{
    QUIC_CTX *ctx = NULL;
    QUIC *quic = NULL;
    TLS *tls = NULL;
    QUIC_BUFFER *buf = NULL;
    BIO *rbio = NULL;
    BIO *wbio = NULL;
    const char *server_hello = NULL;
    size_t msg_len = 0;
    int offset = 0;
    int err = 0;
    int ret = -1;

    ctx = QuicCtxNew(QuicClientMethod());
    if (ctx == NULL) {
        goto out;
    }

    if (TlsCtxClientExtensionSet(ctx) < 0) {
        goto out;
    }

    quic = QuicNew(ctx);
    if (quic == NULL) {
        goto out;
    }

    QUIC_set_connect_state(quic);
    rbio = BIO_new(BIO_s_mem());
    if (rbio == NULL) {
        goto out;
    }

    wbio = BIO_new(BIO_s_mem());
    if (wbio == NULL) {
        goto out;
    }
    QUIC_set_bio(quic, rbio, wbio);

    rbio = NULL;
    wbio = NULL;

    ret = QuicDoHandshake(quic);
    if (ret < 0) {
        err = QUIC_get_error(quic, ret);
        if (err != QUIC_ERROR_WANT_READ) {
            printf("Do Client Handshake failed\n");
            goto out;
        }
    }

    server_hello = TlsFindServerHello(clienthello_serverhello,
            sizeof(clienthello_serverhello) - 1);
    if (server_hello == NULL) {
        goto out;
    }

    offset = (server_hello - clienthello_serverhello)/2;
    printf("offset = %d\n", offset);
    buf = QUIC_TLS_BUFFER(quic);
    str2hex((void *)QuicBufHead(buf), (void *)clienthello_serverhello,
            offset);
    QuicBufSetDataLength(buf, offset);
    QuicBufReserve(buf);
    msg_len = strlen(server_hello)/2;
    str2hex((void *)QuicBufData(buf), (void *)server_hello, msg_len);
    QuicBufSetDataLength(buf, msg_len);
    msg_len = strlen(update_msg)/2;
    str2hex((void *)(QuicBufData(buf) + QuicBufGetDataLength(buf)),
            (void *)update_msg, msg_len);
    QuicBufAddDataLength(buf, msg_len);

    tls = &quic->tls;
    tls->kexch_key = TlsGeneratePkeyGroup(tls, EC_NAMED_CURVE_X25519);
    if (tls->kexch_key == NULL) {
        printf("TLS Gen Pkey Group failed!\n");
        goto out;
    }

    str2hex(tls->handshake_secret, handshake_insecret,
            sizeof(tls->handshake_secret));

    QuicSecretTest = QuicHandshakeSecretComp;
    if (TlsDoHandshake(tls) == QUIC_FLOW_RET_ERROR) {
        printf("TLS Hadshake failed!\n");
        goto out;
    }

    ret = 1;
out:
    BIO_free(wbio);
    BIO_free(rbio);
    QuicFree(quic);
    QuicCtxFree(ctx);
    return ret;
}

